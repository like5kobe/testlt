# 计算机组成原理
### 第7章 指令系统
- 操作码的长度分为固定的和不固定的？弄清楚不固定长度的目的与意义
- 存储字长、机器字长、指令字长、数据字长、数据总线的位数、地址总线的位数
    - 机器字长：
- 系统总线
    - 数据总线：双向传输
    - 地址总线：由CPU输出，单向传输

# C语言
1. 字符的输入/输出

        getchar() 没有参数，函数的返回值就是从终端键盘读入的字符
        putchar(ch) 要输入将输出的字符作为参数
        printf(格式控制字符串，输出值参数表) 通过格式控制字符串 %c 可以输出字符
            以下两条语句等价：
                printf("\n")
                putchar('\n')
        scanf(格式控制字符串，参数地址表) 注意：在以 %c 格式读入字符时，空格字符和转义字符（包括回车）都会被当做有效字符读入
2. 字符串的输入/输出

        按 %c 格式符，一个字符一个字符地单独输入/输出
        按 %s 格式符，将字符串作为一个整体输入/输出
            scanf("%s", str); 不能输入带空格的字符串，当读到空格、回车或制表符等空白字符时，系统认为数据读入结束
            printf("%s", str);
        使用字符串处理函数 gets(),可以输入带空格的字符串
            gets()以回车符作为字符串的终止符，同时将回车符从输入缓冲区读走，但不作为字符串的一部分。而scanf()不读走回车符，回车符仍留在输入缓冲区中。
        puts()输出字符串 
            用于从括号内的参数给出的地址开始，依次输出存储单元中的字符，当遇到第一个'\0'时输出结束，并且自动输出，一个换行符。 
        gets()和scanf(),不能限制输入字符串的长度，很容易引起缓冲区溢出。确保输入字符串的长度不超过数组的大小。
        限制输入字符串长度的函数：fgets(name, sizeof(name), stdin)
            
# Golang
- Go语言为啥要把变量类型后置



# Java
1. 如何理解`final`修饰符，其与C语言中的`const`有何区别？
    - C语言中被`const`修饰的标识符为常量，通常大写，放在只读存储区中，其值是不能修改的。
    - Java中被`final`修饰的标识符变量是放在内存中什么区域的？  

- Java中为何要区分成员变量和类变量？
    - Java类中共有三种变量：类变量（静态变量）、成员变量（实例变量）、局部变量
    - 类变量通过修饰符`static`声明
    
            - 静态变量属于类，该类不生产对象，通过类名就可以调用静态变量。  
            - 实例变量属于该类的对象，必须产生该类对象，才能调用实例变量。  
            - 在程序运行时的区别：  
                - 实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。  
                - 静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。  
            总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。  

- 如何理解Java中的接口？

- 源文件的声明：
    - 一个源文件中只能有一个public类
    - 一个源文件中可以有多个非public类
    - 源文件的名称应该和public类的名称一致
    - **如果一个类定义在某个包中，那么package语句应该在源文件的首行。**  该句如何理解？
    - 如果源文件包含import语句，那么应该放在package语句和类定义之间

- 访问修饰符

        default
        public  public 类分布在不同的包中，则需要导入相应 public 类所在的包
                Java 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。
        protected  被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。
        private  Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。
    - 请注意以下方法继承的规则：
        - 父类中声明为 public 的方法在子类中也必须为 public。
        - 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。
        - 父类中声明为 private 的方法，不能够被继承。

- 非访问修饰符
    
        static 用来修饰类方法和类变量
        final 用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。
    - `static`
        - 静态变量（类变量）
            - static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。
        - 静态方法（类方法）
            - static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。
    - `final`
        - final变量
            - final 变量能被显式地初始化并且只能初始化一次。**被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。** 如何理解？ 这里的描述与常量定义后不可修改是否矛盾？
            - final 修饰符通常和 static 修饰符一起使用来创建类常量。
        - final方法
            - 类中的 final 方法可以被子类继承，但是不能被子类修改。
            - 声明 final 方法的主要目的是防止该方法的内容被修改。
        - final类
            - final 类不能被继承，没有类能够继承 final 类的任何特性。

                    JAVA 的类（外部类）有 2 种访问权限: public、default。
                    而方法和变量有 4 种：public、default、protected、private。
                    其中默认访问权限和 protected 很相似，有着细微的差别。
                     public 意味着任何地方的其他类都能访问。
                     default 则是同一个包的类可以访问。
                     protected 表示同一个包的类可以访问，其他的包的该类的子类也可以访问。
                     private 表示只有自己类能访问。
                    修饰符：abstract、static、final
                     abstract: 表示是抽象类。 使用对象：类、接口、方法
                     static: 可以当做普通类使用，而不用先实例化一个外部类。（用他修饰后，就成了静态内部类了）。 使用对象：类、变量、方法、初始化函数（注意：修饰类时只能修饰内部类 ）
                     final: 表示类不可以被继承。 使用对象：类、变量、方法

- 一般使用数字的时候就是使用内置的数据类型，为什么Java中要使用对象？
    - 如何理解装箱和拆箱？

- 抽象类
    - 定义：如果一个类中没有足够的信息来描述一个具体的对象，这样的类就是抽象类。
    - 性质：
        - 抽象类不能实例化对象，只能被继承使用
        - **一个类只能继承一个抽象类，但一个类可以实现多个接口**
- 抽象方法
    - 抽象方法只包含一个方法名，而没有方法体
    - 性质：
        - 如果一个类包含抽象方法，则该类必定是抽象类
        - 任何子类必须重写父类的抽象方法，或者声明自身为抽象类
            - 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。
    - 总结
        1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
        2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
        3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
        4. 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。
        5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类

- Java接口
    - 接口是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。是隐式抽象的，不需要用`abstract`声明
    - 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。类使用`implements`关键字实现接口
    - 接口与类的区别：
        1. 接口不能用于实例化对象。
        2. 接口没有构造方法。
        3. 接口中所有的方法必须是抽象方法。
        4. 接口不能包含成员变量，除了 static 和 final 变量。
        5. 接口不是被类继承了，而是要被类实现。
        6. 接口支持多继承。通过`extends`实现
    - 接口特性：
        1. 接口中每一个方法也是隐式抽象的，不需要用`abstract`声明
        2. 接口中可以含有变量
        3. 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。
    - 抽象类和接口的区别：
        1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
        2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。
        3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
        4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。