## RabbitMQ
- 生产者：
    - 创建消息
    - 设置标签
- 消费者
    - 订阅队列
    - 只得到有效载荷
- 信道
    - 建立在TCP连接上的虚拟连接
    - 每条信道会被指派唯一的ID
    - 发布消息、订阅队列、接收消息都需通过信道完成
    - 可以保证线程连接到RabbitMQ的私密通信

- AMQP消息路由组成：
    - 交换器
    - 队列
    - 绑定

### 队列
- 消费者接收消息的方式：
    - 持续订阅：basic.consume
    - 获得单条消息：basic.get

- 至少有一个消费者订阅了队列，消息会立即发送给订阅的消费者
- 无人订阅队列，消息会在队列中等待
- 当队列有多个消费者时，队列收到的消息将以循环的方式发送给消费者。每条消息只会发送给一个订阅的消费者。

- 消费者接收到的每一条消息都必须进行确认，同时RabbitMQ将消息从队列中删除
    - 显示地发送一个确认：basic.ack
    - 订阅到队列的时候将auto_ack 设置为True，一旦消费者接收消息会自动视为确认了消息

- 若消费者收到一条消息，在确认之前从Rabbit断开连接（或从队列上取消订阅），RabbitMQ会认为这条消息没有分发，然后重新分发给下一个订阅的消费者

- 收到消息后，想要明确拒绝而不是确认收到该消息的方式：
    - 把消费者从RabbitMQ服务器断开连接
    - basic.reject
        - 若将requeue设置为True，RabbitMQ会重新发送消息给下一个订阅的消费者。
        - 若将requeue设置为False，RabbitMQ立即将消息从队列中移除

- 创建队列
    - queue.declare
    - 若消费者在同一条信息上订阅了另一个队列的话，就无法再声明队列了。必须先取消订阅，将信息置为“传输”模式
    - 队列设置中的参数：
        - exclusive，若设置为True，队列变为私有的，只有你的应用程序才能够消费队列消息
        - auto-delete，当最后一个消费者取消订阅的时候，队列会自动移除

- 若声明一个已经存在的队列，只要声明参数完全匹配现存队列的话，Rabbit什么都不做，会成功返回。若参数不匹配的话，队列声明会失败
- 若只想检测队列是否存在，将queue.declare的passive设置为True
    - 若队列存在，queue.declare会成功返回
    - 若队列不存在，不会创建队列而会返回一个错误

### 交换器和绑定
- 队列通过路由键绑定到交换器。如果路由的消息不匹配任何绑定模式的话，消息将进入“黑洞”
- 声明交换器：exchange.declare

- direct交换器
    - 路由键匹配
- fanout交换器
    - 将消息广播到绑定的队列上
- topic交换器
    - 可以使来自不同源头的消息能够到达同一个队列
